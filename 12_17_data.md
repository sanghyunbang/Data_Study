# JOIN의 기초부터 이해하기

## 1. JOIN이란?
JOIN은 데이터베이스에서 두 개 이상의 테이블을 연결하여 데이터를 가져오는 작업입니다.

- 테이블 간의 **공통 열(Column)**을 기준으로 데이터를 연결합니다.
- **정규화(Normalization)**를 통해 데이터를 나누어 저장하기 때문에 JOIN이 필요합니다.

### 예시: 쇼핑몰 데이터 구조
- **Customer 테이블**: 고객의 정보 (고객 ID, 이름, 주소 등)
- **Order 테이블**: 고객의 주문 정보 (주문 ID, 고객 ID, 주문 날짜 등)

**JOIN**을 통해 "어떤 고객이 어떤 주문을 했는지" 알 수 있습니다.

## 1.2 JOIN의 기본 종류

### 1. INNER JOIN
- 두 테이블에서 **공통된 값이 있는 데이터만 반환**합니다.
- **비유**: 두 명단에서 겹치는 사람만 찾는 것.

### 2. LEFT JOIN
- **왼쪽 테이블의 모든 데이터**와 오른쪽 테이블의 공통된 데이터를 반환합니다. (왼쪽 테이블 우선)
- **비유**: 왼쪽 명단의 모든 사람을 가져오고, 오른쪽 명단과 겹치는 정보만 추가.

### 3. RIGHT JOIN
- **오른쪽 테이블의 모든 데이터**와 왼쪽 테이블의 공통된 데이터를 반환합니다. (오른쪽 테이블 우선)

### 4. FULL OUTER JOIN
- **두 테이블의 모든 데이터**를 반환하며, 공통되지 않는 데이터는 NULL로 표시합니다. (합집합)

---

## 2. INNER JOIN 자세히 알아보기

### 2.1 INNER JOIN이란?
INNER JOIN은 두 테이블의 공통된 값이 있는 데이터만 반환합니다.

**비유**: 축구팀과 농구팀의 명단이 있다고 합시다.
- **명단 A (축구팀)**: {영희, 철수, 민수}
- **명단 B (농구팀)**: {철수, 민수, 지영}
- **INNER JOIN 결과**: 두 팀 모두에 속한 {철수, 민수}

### 2.2 SQL에서의 INNER JOIN 예제

**Customers 테이블**
| CustomerID | CustomerName | City      |
|------------|--------------|-----------|
| 1          | John         | New York  |
| 2          | Alice        | London    |
| 3          | Bob          | Paris     |

**Orders 테이블**
| OrderID | CustomerID | OrderDate  |
|---------|------------|------------|
| 101     | 1          | 2024-01-01 |
| 102     | 3          | 2024-01-02 |
| 103     | 4          | 2024-01-03 |

**INNER JOIN 쿼리**:
```sql
SELECT Customers.CustomerID, Customers.CustomerName, Orders.OrderID, Orders.OrderDate
FROM Customers
INNER JOIN Orders
ON Customers.CustomerID = Orders.CustomerID;
```

**INNER JOIN 결과**:
| CustomerID | CustomerName | OrderID | OrderDate  |
|------------|--------------|---------|------------|
| 1          | John         | 101     | 2024-01-01 |
| 3          | Bob          | 102     | 2024-01-02 |

**설명**:
- CustomerID가 **양쪽 테이블에 존재하는 값**만 반환됩니다.
- CustomerID = 4인 데이터는 Customers 테이블에 없으므로 제외.
- CustomerID = 2인 데이터는 Orders 테이블에 없으므로 제외.

---

## 3. INNER JOIN의 내부 동작 이해하기

SQL Server는 JOIN을 처리할 때 다양한 방식으로 데이터를 비교합니다.

### 3.1 JOIN의 주요 처리 방식

#### 1. Nested Loops Join
- **작은 데이터셋**에서 적합합니다.
- 한 테이블의 각 행을 다른 테이블의 모든 행과 비교합니다.
- **비유**: 두 그룹의 사람들이 서로 악수를 하는 것.

#### 2. Merge Join
- **정렬된 테이블**에서 적합합니다.
- 두 테이블을 병합하며 데이터를 비교합니다.
- **비유**: 정렬된 두 줄에서 서로 짝을 맞추는 방식.

#### 3. Hash Match Join
- **큰 데이터셋**에서 적합합니다.
- 작은 테이블을 **해시 테이블**로 변환해 비교합니다.
- **비유**: 사람들이 명찰을 차고 이름으로 그룹을 짓는 방식.

---

## 4. HASH JOIN 자세히 알아보기

### 4.1 HASH JOIN이란?
Hash Join은 하나의 테이블 데이터를 **해시 테이블(Hash Table)**로 변환한 뒤, 다른 테이블과 비교하는 방식입니다.

**동작 과정**:
1. **Build 단계**: 작은 테이블을 해시 테이블로 변환합니다.
2. **Probe 단계**: 해시 테이블을 사용해 큰 테이블의 데이터를 비교하고 조건에 맞는 데이터를 반환합니다.

### 4.2 HASH JOIN이 적합한 상황
- **큰 테이블끼리 JOIN**할 때.
- 테이블이 **정렬되지 않은 상태**일 때.
- 정렬된 테이블이 아니라면, Merge Join 대신 Hash Join이 선택됩니다.

**실제 예제**:
```sql
SELECT E.EmployeeID, E.EmployeeName, D.DepartmentName
FROM Employees E
INNER JOIN Departments D
ON E.EmployeeID = D.EmployeeID;
```

---

## 5. 정리

- **INNER JOIN**: 두 테이블에서 공통된 데이터를 연결합니다.
- **HASH JOIN**: 큰 테이블이나 정렬되지 않은 데이터를 효율적으로 JOIN하는 방식입니다.
- **인덱스**: JOIN의 성능을 크게 개선합니다. 인덱스가 없으면 Table Scan이 발생할 수 있습니다.

---

## 6. INNER JOIN 최적화와 인덱스의 역할

### 6.1 INNER JOIN이 느려질 수 있는 이유
INNER JOIN은 두 테이블의 공통된 값을 기반으로 데이터를 연결합니다.
하지만 테이블 크기가 크거나 인덱스가 없으면 성능이 크게 저하될 수 있습니다.

#### a. 큰 테이블끼리 JOIN
- 테이블에 데이터가 많을수록 SQL Server는 모든 데이터를 비교해야 하므로 시간이 오래 걸립니다.
- **예시**:
  - Employees 테이블: 100만 행
  - Departments 테이블: 50만 행
  - EmployeeID를 기준으로 JOIN 시, 최악의 경우 100만 × 50만 번 비교.

#### b. 인덱스가 없을 때
- 테이블에 **인덱스(Index)**가 없으면 SQL Server는 테이블의 모든 데이터를 읽어야 합니다.
- 이를 **Table Scan**이라고 하며, 데이터 크기가 클수록 시간이 오래 걸립니다.

### 6.2 인덱스(Index)가 INNER JOIN에 미치는 영향

#### a. 인덱스란?
- **인덱스(Index)**는 테이블의 특정 열을 기준으로 데이터를 빠르게 검색할 수 있는 데이터 구조입니다.
- **비유**: 책의 색인(Index)처럼 특정 키워드를 빠르게 찾는 것.

#### b. 인덱스 없는 경우 vs 있는 경우
- **인덱스 없는 경우 (Table Scan)**: 테이블의 모든 데이터를 처음부터 끝까지 스캔합니다.
- **인덱스 있는 경우 (Index Seek)**: 인덱스를 사용해 조건에 맞는 데이터를 바로 찾습니다.

### 6.3 INNER JOIN에서의 인덱스 최적화

#### a. 상황 예제
**Employees 테이블**
| EmployeeID | EmployeeName |
|------------|--------------|
| 1          | Alice        |
| 2          | Bob          |
| 3          | Charlie      |

**Departments 테이블**
| DepartmentID | EmployeeID | DepartmentName |
|-------------|------------|----------------|
| 10          | 1          | HR             |
| 20          | 2          | IT             |
| 30          | 4          | Marketing      |

#### b. 인덱스 없는 상태에서 JOIN
```sql
SELECT E.EmployeeID, E.EmployeeName, D.DepartmentName
FROM Employees E
INNER JOIN Departments D
ON E.EmployeeID = D.EmployeeID;
```
- SQL Server는 Employees와 Departments의 모든 데이터를 비교합니다.

#### c. 인덱스 추가 후 JOIN
```sql
CREATE INDEX IX_EmployeeID ON Employees(EmployeeID);
CREATE INDEX IX_EmployeeID ON Departments(EmployeeID);

SELECT E.EmployeeID, E.EmployeeName, D.DepartmentName
FROM Employees E
INNER JOIN Departments D
ON E.EmployeeID = D.EmployeeID;
```
- **결과**: 인덱스를 사용하면 SQL Server는 **Index Seek**을 통해 데이터를 빠르게 검색하고 성능을 향상시킵니다.

---

## 7. HASH JOIN과의 관계

### 7.1 INNER JOIN에서 HASH JOIN이 선택되는 경우
SQL Server는 JOIN을 처리할 때 테이블의 크기와 정렬 상태를 기반으로 JOIN 전략을 선택합니다.

#### a. HASH JOIN이 선택되는 경우
- 테이블이 **정렬되지 않은 상태**일 때.
- **큰 테이블**끼리 JOIN할 때 SQL Server는 Hash Join을 선택합니다.

#### b. HASH JOIN 동작 방식
1. **Build 단계**: 작은 테이블의 데이터를 해시 테이블로 만듭니다.
2. **Probe 단계**: 큰 테이블의 데이터를 해시 테이블과 비교해 조건을 충족하는 데이터를 반환합니다.

### 7.2 HASH JOIN과 인덱스의 영향
- **인덱스 없는 경우**: 테이블이 정렬되지 않은 상태에서 Hash Join이 실행됩니다.
- **인덱스 추가 시**: 데이터가 정렬되면 Merge Join이 선택될 수 있습니다.

---

## 8. 실제 상황에서의 적용

### 8.1 HEADER와 DETAIL의 개념
**HEADER**: 상위 정보(예: 주문 번호, 고객 ID, 주문 날짜)를 포함하는 테이블.
**DETAIL**: 세부 정보(예: 상품 ID, 수량)를 포함하는 테이블.

**예시**:
- **SalesOrderHeader**: 주문 정보 (SalesOrderID, CustomerID)
- **SalesOrderDetail**: 세부 주문 정보 (SalesOrderID, ProductID)

### 8.2 실습 예제
**테이블 생성**:
```sql
-- SalesOrderHeader 테이블 생성
CREATE TABLE SalesOrderHeader (
    SalesOrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATE
);

-- SalesOrderDetail 테이블 생성
CREATE TABLE SalesOrderDetail (
    SalesOrderID INT,
    ProductID INT,
    Quantity INT
);
```

**데이터 삽입**:
```sql
INSERT INTO SalesOrderHeader VALUES (1, 101, '2024-01-01');
INSERT INTO SalesOrderHeader VALUES (2, 102, '2024-01-02');
INSERT INTO SalesOrderDetail VALUES (1, 1001, 2);
INSERT INTO SalesOrderDetail VALUES (2, 1002, 3);
```

**INNER JOIN 실행**:
```sql
SELECT H.SalesOrderID, H.CustomerID, D.ProductID, D.Quantity
FROM SalesOrderHeader H
INNER JOIN SalesOrderDetail D
ON H.SalesOrderID = D.SalesOrderID;
```

**결과**:
| SalesOrderID | CustomerID | ProductID | Quantity |
|--------------|------------|-----------|----------|
| 1            | 101        | 1001      | 2        |
| 2            | 102        | 1002      | 3        |

---

이제 HASH JOIN, HEADER 개념 및 실제 SQL 예제까지 모두 정리했습니다! 추가적으로 궁금한 점이 있다면 말씀해 주세요. 😊
