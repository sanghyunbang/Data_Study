## 목차

1. SQL 성능 최적화란?  
2. SARGABLE 조건과 인덱스 활용  
   - 2.1. YEAR 함수 문제와 해결 방법  
   - 2.2. LEFT 함수 문제와 테이블 스캔  
3. Key Lookup과 INCLUDE로 최적화  
   - 3.1. Key Lookup이란?  
   - 3.2. INCLUDE를 통한 Key Lookup 방지  
4. 데이터 타입 및 열 길이 최적화  
   - 4.1. LEN 함수로 데이터 길이 분석  
   - 4.2. 열 길이 최적화 효과  
5. 정렬(Sort) 작업과 인덱스  
6. Stored Procedure와 실행 계획 관리  
   - 6.1. 실행 계획 캐시와 캐시된 실행 계획  
   - 6.2. WITH RECOMPILE의 역할  
   - 6.3. 캐시된 실행 계획 문제와 해결  
7. 디스크 I/O와 쿼리 성능  
8. Join 방식과 인덱스 최적화  
   - 8.1. Nested Loop Join vs Hash Join  
   - 8.2. 인덱스가 Join 성능에 미치는 영향  
9. 실습: 성능 최적화 전후 비교  
10. 결론 및 추가 학습 자료

---

## 💡 1. SQL 성능 최적화란?

**SQL 성능 최적화**는 데이터베이스에서 실행되는 SQL 쿼리의 효율성을 향상시키는 과정입니다. 이는 응답 시간을 줄이고 시스템 자원 사용을 최소화하여 전체적인 데이터베이스 성능을 개선합니다.

- **왜 필요한가?**
  - 대용량 데이터 처리 시 성능 문제는 시스템 부하 증가와 사용자 경험 저하로 이어집니다.
  - 최적화를 통해 빠른 응답 시간과 효율적인 자원 활용을 달성할 수 있습니다.

---

## 🚀 2. SARGABLE 조건과 인덱스 활용

**SARGABLE**은 "Search ARGument ABLE"의 약자로, 쿼리 조건이 인덱스를 효율적으로 사용할 수 있는지를 나타냅니다.

### 🛠 2.1 YEAR 함수 문제와 해결 방법

- **문제 쿼리**

  ```sql
  SELECT city 
  FROM SalesLT.Address
  WHERE YEAR(ModifiedDate) = 2006
  ```

- **문제 설명**

  - `YEAR(ModifiedDate) = 2006`은 `ModifiedDate` 열의 모든 행에 대해 `YEAR()` 함수를 적용해야 합니다.
  - 이로 인해 인덱스를 사용할 수 없고, **테이블 스캔(Table Scan)**이 발생합니다.
  - **테이블 스캔**은 전체 테이블을 처음부터 끝까지 읽는 것으로, 데이터 양이 많을수록 성능 저하가 심해집니다.

- **해결 방법**

  ```sql
  SELECT city 
  FROM SalesLT.Address
  WHERE ModifiedDate BETWEEN '2006-01-01' AND '2006-12-31 23:59:59'
  ```

  - `ModifiedDate`에 직접 범위 조건을 사용하면 인덱스를 활용할 수 있습니다.
  - 이로써 **인덱스 시크(Index Seek)**가 가능해져 성능이 크게 향상됩니다.

- **비유**

  - 테이블 스캔은 도서관에서 책 한 권을 찾기 위해 모든 책을 하나씩 확인하는 것과 같습니다.
  - 인덱스 시크는 책이 분류된 카테고리를 통해 원하는 책을 바로 찾는 것과 같습니다.

---

### 🔍 2.2 LEFT 함수 문제와 테이블 스캔

- **문제 쿼리**

  ```sql
  SELECT * 
  FROM SalesLT.Address
  WHERE LEFT(AddressLine1, 1) = '8'
  ```

- **문제 설명**

  - `LEFT(AddressLine1, 1)`은 `AddressLine1` 열의 모든 행에 대해 첫 글자를 추출합니다.
  - 이 함수 사용으로 인해 인덱스를 사용할 수 없고, **테이블 스캔**이 발생합니다.
  - **테이블 스캔으로 인한 성능 저하**: 데이터 양이 많을수록 전체 테이블을 읽는 데 시간이 오래 걸립니다.

- **해결 방법**

  ```sql
  SELECT * 
  FROM SalesLT.Address
  WHERE AddressLine1 LIKE '8%'
  ```

  - `LIKE '8%'`는 `AddressLine1`이 '8'로 시작하는지를 확인합니다.
  - 이 조건은 인덱스를 활용할 수 있는 **SARGABLE** 조건입니다.
  - 따라서 **인덱스 시크**가 가능하며 성능이 개선됩니다.

- **비유**

  - 함수 사용은 모든 데이터를 변환한 후 조건을 확인하는 것(모든 열쇠를 하나씩 시도하는 것)과 같습니다.
  - `LIKE` 조건은 열쇠고리에서 특정 열쇠 모양(패턴)에 맞는 열쇠만 선택하는 것과 같습니다.

---

## 🔑 3. Key Lookup과 INCLUDE로 최적화

### ❓ 3.1 Key Lookup이란?

- **Key Lookup**은 비클러스터드 인덱스로 원하는 데이터를 모두 가져올 수 없을 때 발생합니다.
- **예시 상황**

  - 인덱스에 `City` 열만 포함되어 있고, 쿼리에서 `ModifiedDate`도 필요로 할 때.
  - SQL 서버는 인덱스를 통해 `City`를 찾은 후, `ModifiedDate`를 얻기 위해 테이블의 해당 행을 다시 조회합니다.

- **문제점**

  - **추가적인 디스크 I/O 발생**: 테이블을 다시 조회해야 하므로 성능 저하.
  - **Key Lookup은 성능에 부정적 영향**을 미칩니다.

### ✅ 3.2 INCLUDE를 통한 Key Lookup 방지

- **해결 방법**

  ```sql
  CREATE NONCLUSTERED INDEX [Ix_Address_City]
  ON SalesLT.Address (City)
  INCLUDE (ModifiedDate)
  ```

  - 인덱스에 `City` 열을 키로 사용하고, `ModifiedDate` 열을 **INCLUDE**로 포함합니다.
  - 이렇게 하면 인덱스 자체에 필요한 모든 데이터가 포함되어 **Key Lookup**을 방지할 수 있습니다.

- **효과**

  - **디스크 I/O 감소**: 추가적인 테이블 조회가 필요 없으므로 성능 향상.
  - **쿼리 성능 개선**: 필요한 데이터를 한 번에 가져올 수 있습니다.

- **비유**

  - **Key Lookup 발생 시**: 쇼핑 리스트에 없는 물건을 위해 다시 마트에 가는 것과 같습니다.
  - **INCLUDE 사용 시**: 처음에 필요한 모든 물건을 쇼핑 리스트에 적어 한 번에 구매하는 것과 같습니다.

---

## 📏 4. 데이터 타입 및 열 길이 최적화

### 📊 4.1 LEN 함수로 데이터 길이 분석

- **문제 상황**

  - `AddressLine1` 열이 `nvarchar(60)`로 설정되어 있으나 실제 데이터는 그보다 짧을 수 있습니다.
  - 불필요하게 큰 데이터 타입은 디스크 공간 낭비와 성능 저하를 초래합니다.

- **데이터 길이 확인**

  ```sql
  SELECT LEN(AddressLine1) AS Length
  FROM SalesLT.Address
  ORDER BY Length DESC
  ```

  - `LEN(AddressLine1)`을 사용하여 각 행의 문자열 길이를 확인합니다.
  - 최대 길이가 39라면, 데이터 타입을 줄일 수 있습니다.

### ✂️ 4.2 열 길이 최적화 효과

- **데이터 타입 변경**

  - `nvarchar(60)` → `nvarchar(50)`로 변경.

- **효과**

  - **디스크 공간 절약**: 데이터 크기가 줄어듭니다.
  - **메모리 사용량 감소**: 작은 크기의 데이터는 메모리 캐시에 더 잘 적재됩니다.
  - **쿼리 성능 향상**: 데이터 전송량이 줄어들어 처리 속도가 빨라집니다.

- **비유**

  - 불필요하게 큰 박스에 작은 물건을 담는 것보다, 딱 맞는 크기의 박스를 사용하는 것이 효율적입니다.

---

## 🔄 5. 정렬(Sort) 작업과 인덱스

- **문제점**

  - 쿼리에서 `ORDER BY` 절을 사용할 때 추가적인 정렬 작업이 필요합니다.
  - 정렬은 많은 리소스를 사용하며 성능을 저하시킬 수 있습니다.

- **해결 방법**

  - 정렬하려는 열에 인덱스를 생성하여 이미 정렬된 데이터를 사용할 수 있습니다.

- **예시**

  ```sql
  SELECT City 
  FROM SalesLT.Address
  ORDER BY City
  ```

  - `City` 열에 인덱스를 생성하면 정렬 없이도 데이터를 가져올 수 있습니다.

- **효과**

  - **쿼리 성능 향상**: 추가적인 정렬 작업을 피할 수 있습니다.
  - **리소스 절약**: CPU 사용량 감소.

- **비유**

  - 이미 정렬된 책 목록을 사용하는 것과, 무작위로 섞인 책들을 다시 정렬하는 것의 차이.

---

## ⚙️ 6. Stored Procedure와 실행 계획 관리

### 📂 6.1 실행 계획 캐시와 캐시된 실행 계획

- **실행 계획이란?**

  - SQL 서버가 쿼리를 실행하기 위해 생성하는 단계별 처리 방법.
  - 최적의 성능을 위해 쿼리를 어떻게 실행할지 결정합니다.

- **캐시(Cache)란?**

  - 자주 사용되는 데이터나 실행 계획을 메모리에 저장하여 빠르게 접근할 수 있게 하는 공간.
  - SQL 서버는 실행 계획을 캐시에 저장하여 다음에 동일한 쿼리가 실행될 때 재사용합니다.

- **캐시된 실행 계획의 문제점**

  - 매개변수 값에 따라 최적의 실행 계획이 달라질 수 있습니다.
  - 이전에 생성된 실행 계획이 모든 경우에 최적이 아닐 수 있습니다.

### 🌀 6.2 WITH RECOMPILE의 역할

- **WITH RECOMPILE** 옵션은 프로시저가 실행될 때마다 새로운 실행 계획을 생성하도록 합니다.

- **예시**

  ```sql
  CREATE PROCEDURE NameOfProc (@Year INT)
  WITH RECOMPILE
  AS
  BEGIN
      SELECT * 
      FROM SalesLT.Address
      WHERE ModifiedDate BETWEEN @Year + '-01-01' AND @Year + '-12-31'
  END
  ```

- **효과**

  - 매번 최신의 데이터 분포에 맞는 최적의 실행 계획을 생성합니다.
  - 특정 매개변수 값에 최적화된 실행 계획을 사용합니다.

---

### 🛑 6.3 캐시된 실행 계획 문제와 해결

- **문제 상황**

  - `@Year = 2006`일 때는 데이터가 많고, `@Year = 2007`일 때는 데이터가 적은 경우.
  - `2006`에 최적화된 실행 계획이 `2007`에 사용되면 비효율적일 수 있습니다.

- **해결 방법**

  - `WITH RECOMPILE`을 사용하여 매번 실행 계획을 재생성합니다.
  - 또는 `OPTION (RECOMPILE)`을 쿼리 끝에 추가할 수 있습니다.

  ```sql
  SELECT * 
  FROM SalesLT.Address
  WHERE ModifiedDate BETWEEN @StartDate AND @EndDate
  OPTION (RECOMPILE)
  ```

- **비유**

  - 날씨에 따라 옷을 달리 입어야 하는데, 항상 같은 옷을 입는 것과 같습니다.
  - `RECOMPILE`은 매번 날씨에 맞게 옷을 고르는 것과 같습니다.

---

## 💾 7. 디스크 I/O와 쿼리 성능

- **디스크 I/O(Input/Output)**

  - 디스크에서 데이터를 읽거나 쓰는 작업.
  - 디스크 접근은 메모리보다 느리기 때문에, 디스크 I/O가 많을수록 쿼리 성능이 저하됩니다.

- **쿼리 성능이란?**

  - 쿼리가 실행되는 속도와 자원 사용 효율을 말합니다.
  - **높은 쿼리 성능**은 빠른 응답 시간과 낮은 자원 사용량을 의미합니다.

- **디스크 I/O 감소 방법**

  - 필요한 데이터만 선택적으로 조회.
  - 인덱스 활용으로 불필요한 데이터 접근 최소화.
  - 불필요한 열 조회 방지(`SELECT *` 대신 필요한 열만 선택).

- **비유**

  - 필요한 책만 골라보는 것과 도서관의 모든 책을 다 꺼내보는 것의 차이.

---

## 🤝 8. Join 방식과 인덱스 최적화

### 🔄 8.1 Nested Loop Join vs Hash Join

- **Nested Loop Join**

  - 한 테이블의 각 행에 대해 다른 테이블을 검색.
  - 작은 데이터셋이나 적절한 인덱스가 있을 때 효율적.

- **Hash Join**

  - 두 테이블의 데이터를 해시 테이블에 저장하여 매칭.
  - 대용량 데이터셋에 적합하며, 인덱스가 없어도 효율적.

### 🗂️ 8.2 인덱스가 Join 성능에 미치는 영향

- **인덱스 활용으로 Join 성능 개선**

  - Join에 사용되는 열에 인덱스를 생성하면 **Nested Loop Join**의 성능이 향상됩니다.
  - 인덱스가 없으면 **Hash Join**이나 **Merge Join**이 사용되며, 경우에 따라 성능이 저하될 수 있습니다.

- **예시**

  ```sql
  SELECT *
  FROM Orders o
  INNER JOIN Customers c ON o.CustomerID = c.CustomerID
  ```

  - `CustomerID` 열에 인덱스가 있으면 Join 속도가 빨라집니다.

- **비유**

  - 전화번호부에 이름별로 정렬되어 있으면 사람을 찾기 쉽지만, 무작위로 섞여 있으면 찾기 어렵습니다.

---

## 🧪 9. 실습: 성능 최적화 전후 비교

### 🛠️ 9.1 초기 상태

- **문제 쿼리**

  ```sql
  SELECT * 
  FROM SalesLT.Address
  WHERE YEAR(ModifiedDate) = 2006
  ```

- **문제점**

  - `YEAR()` 함수로 인한 테이블 스캔 발생.
  - 인덱스를 사용할 수 없어 성능 저하.

### ✅ 9.2 최적화 후

- **개선된 쿼리**

  ```sql
  SELECT * 
  FROM SalesLT.Address
  WHERE ModifiedDate BETWEEN '2006-01-01' AND '2006-12-31 23:59:59'
  ```

- **개선점**

  - SARGABLE 조건으로 변경하여 인덱스 시크 가능.
  - 쿼리 실행 속도 향상.

### 🔍 9.3 실행 계획 비교

- **실행 계획 확인 방법**

  - 쿼리 실행 시 `실행 계획 보기` 옵션을 활성화하여 그래픽 실행 계획을 확인합니다.
  - 테이블 스캔과 인덱스 시크의 차이를 시각적으로 확인할 수 있습니다.

- **비교 결과**

  - **최적화 전**: 테이블 스캔 발생, 높은 CPU 및 디스크 I/O 사용.
  - **최적화 후**: 인덱스 시크로 필요한 데이터만 조회, 리소스 사용량 감소.

---

## 🏁 10. 결론 및 추가 학습 자료

- **결론**

  - SQL 성능 최적화는 쿼리의 효율성을 높이고 시스템 자원 사용을 최소화하는 데 필수적입니다.
  - 작은 변경으로도 큰 성능 향상을 얻을 수 있습니다.

- **추가 학습 자료**

  - **Microsoft SQL Server 공식 문서**
    - [SQL Server 인덱스 설계 및 아키텍처 가이드](https://docs.microsoft.com/ko-kr/sql/relational-databases/indexes)
  - **온라인 강좌**
    - Udemy, Coursera 등의 SQL 성능 최적화 강의
  - **도서**
    - "SQL 성능 튜닝 이야기" - 성능 최적화에 대한 심층적인 설명 제공

