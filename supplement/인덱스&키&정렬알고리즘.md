# 데이터베이스 인덱스와 키, 정렬 알고리즘 강의 자료

## 1. 기본키, 외래키, 유니크 키

### 1.1 기본키 (Primary Key)
- **정의**: 테이블에서 각 행을 고유하게 식별할 수 있는 컬럼.
- **제약 조건**:
  - 중복 불가: 기본키의 값은 중복될 수 없습니다.
  - NULL 값 허용 불가: 기본키는 NULL 값을 가질 수 없습니다.
  - 한 테이블에 하나만 설정 가능.
- **용도**:
  - 테이블의 각 레코드를 고유하게 식별.
  - 외래키(Foreign Key)로 참조되어 다른 테이블 간 관계를 정의.

#### 예시:
```sql
CREATE TABLE Students (
    StudentID INT PRIMARY KEY,
    Name VARCHAR(100),
    Age INT
);
```

### 1.2 외래키 (Foreign Key)
- **정의**: 다른 테이블의 기본키를 참조하는 컬럼.
- **제약 조건**:
  - 참조 무결성을 유지: 외래키 값은 참조하는 기본키 값과 일치해야 합니다.
  - 삭제 또는 갱신 시 제약 조건 설정 가능 (예: `ON DELETE CASCADE`).
- **용도**:
  - 테이블 간 관계를 정의하고 데이터 무결성을 유지.

#### 예시:
```sql
CREATE TABLE Enrollments (
    EnrollmentID INT PRIMARY KEY,
    StudentID INT,
    CourseID INT,
    FOREIGN KEY (StudentID) REFERENCES Students(StudentID)
);
```

### 1.3 유니크 키 (Unique Key)
- **정의**: 특정 컬럼의 값이 고유함을 보장하는 제약 조건.
- **제약 조건**:
  - 중복 불가: 값이 고유해야 합니다.
  - NULL 값 허용 가능: 일부 DBMS에서는 여러 개의 NULL 값을 허용.
- **용도**:
  - 기본키 외에 유일성을 보장해야 하는 경우 사용.

#### 예시:
```sql
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    Email VARCHAR(100) UNIQUE
);
```

### 1.4 기본키와 유니크 키의 주요 차이점
| **특성**             | **기본키 (Primary Key)**        | **유니크 키 (Unique Key)**        |
|----------------------|--------------------------------|----------------------------------|
| **NULL 값 허용 여부** | 허용하지 않음                   | NULL 값 허용 가능                 |
| **중복 여부**         | 중복 불가                      | 중복 불가                        |
| **자동 인덱스 생성**  | 예                            | 예                              |
| **용도**             | 테이블의 행 식별                | 특정 컬럼의 유일성 보장           |

---

## 2. B-Tree 구조와 데이터베이스 인덱스

### 2.1 B-Tree 구조란?
- **정의**: 데이터베이스에서 사용되는 정렬된 트리 기반 데이터 구조로, 효율적인 검색, 삽입, 삭제를 지원.
- **특징**:
  - 데이터는 항상 정렬된 상태로 저장.
  - 트리의 모든 리프 노드는 동일한 깊이를 가짐.
  - **O(log n)** 시간 복잡도로 검색 가능.
  - 삽입/삭제 시에도 정렬과 균형을 유지.

### 2.2 B-Tree의 주요 동작
1. **검색(Search)**:
   - 루트 노드에서 시작해 키 값을 비교하며 자식 노드로 이동.
   - 리프 노드에 도달하면 검색 완료.

2. **삽입(Insertion)**:
   - 적절한 위치에 데이터를 삽입하며 정렬 상태 유지.
   - 노드가 가득 차면 **분할(Split)**로 균형 유지.

3. **삭제(Deletion)**:
   - 데이터를 삭제한 후, 노드 크기가 최소 한도(M/2) 아래로 떨어지면 **병합(Merge)** 또는 **재분배(Redistribution)**으로 균형 유지.

### 2.3 B+Tree와의 차이
- **B+Tree**는 B-Tree의 확장판으로, 리프 노드에만 실제 데이터를 저장하며 범위 검색에 유리.
- 리프 노드는 연결 리스트로 연결되어 있어 순차 접근이 빠름.

---

## 3. 인덱스 생성 및 확인

### 3.1 인덱스 생성 방법
1. **명시적으로 생성**:
   - 개발자가 직접 인덱스를 생성.
   ```sql
   CREATE INDEX IDX_ModifiedDate ON SalesLT.Address (ModifiedDate);
   ```

2. **자동 생성 (기본키/유니크 키 기반)**:
   - 기본키 또는 유니크 키를 설정하면 데이터베이스가 자동으로 인덱스를 생성.
   ```sql
   CREATE TABLE SalesLT.Address (
       ID INT PRIMARY KEY,
       ModifiedDate DATETIME
   );
   ```

### 3.2 인덱스 확인 방법
1. **데이터베이스 관리 툴 사용**:
   - MySQL:
     ```sql
     SHOW INDEX FROM SalesLT.Address;
     ```

2. **쿼리 실행 계획 확인**:
   - `EXPLAIN` 키워드를 사용해 쿼리에서 인덱스가 사용되는지 확인.
   ```sql
   EXPLAIN SELECT City
   FROM SalesLT.Address
   WHERE ModifiedDate BETWEEN '2006-01-01' AND '2006-12-31 23:59:59';
   ```
   - 결과:
     - `key` 열에 인덱스 이름이 표시되면, 해당 쿼리가 인덱스를 사용.

---

## 4. 인덱스와 정렬의 관계

### 4.1 인덱스는 항상 정렬된 구조를 유지
- 데이터베이스에서 인덱스는 **B-Tree** 또는 이와 유사한 정렬된 자료 구조로 관리됩니다.
- 데이터가 테이블에 순서대로 저장되지 않더라도, 인덱스 자체는 항상 정렬 상태를 유지합니다.
- 예:
  - 테이블의 `ModifiedDate` 값이 랜덤하게 추가되더라도, 인덱스는 이 값을 정렬된 상태로 별도의 구조에 저장.

### 4.2 정렬되지 않은 테이블에서도 인덱스는 유리
1. **테이블의 데이터가 정렬되지 않은 경우**:
   - 테이블의 `ModifiedDate` 값이 순서 없이 저장되어 있어도, 인덱스를 조회하면 정렬된 데이터를 기반으로 빠르게 검색 가능.

2. **인덱스가 없을 경우**:
   - 데이터베이스는 테이블의 모든 행을 하나씩 확인해야 하며, 이를 **테이블 스캔(Table Scan)**이라고 부릅니다.

3. **인덱스가 있을 경우**:
   - 데이터베이스는 인덱스의 정렬된 구조를 사용하여 필요한 범위만 효율적으로 검색.
   - 이 과정을 **인덱스 시크(Index Seek)**라고 합니다.

### 4.3 BETWEEN이 유리한 이유
- `BETWEEN` 조건은 정렬된 인덱스 구조의 강점을 활용합니다.

#### 예제:
```sql
-- 테이블 데이터
| ID  | ModifiedDate |
|-----|--------------|
| 1   | 2005-12-30   |
| 2   | 2006-01-01   |
| 3   | 2006-06-15   |
| 4   | 2006-12-31   |
| 5   | 2007-01-01   |

-- 쿼리
SELECT City
FROM SalesLT.Address
WHERE ModifiedDate BETWEEN '2006-01-01' AND '2006-12-31';
```
- 실행 과정:
  1. 인덱스에서 `2006-01-01` 값을 찾음 (시작 지점).
  2. 정렬된 구조를 따라 `2006-12-31`까지의 데이터를 읽음.
  3. 나머지 값은 건너뜀 (예: `2005-12-30`, `2007-01-01` 등).

#### **인덱스가 없으면?**
- 모든 데이터를 처음부터 끝까지 확인하며 조건에 맞는 행을 찾습니다.
- 조건에 맞지 않는 데이터도 모두 읽어야 하므로 비효율적입니다.

---

## 5. YEAR() 함수와 성능 문제
- `YEAR(ModifiedDate)` 조건은 `ModifiedDate` 컬럼 값을 함수로 변환하여 비교.
- 인덱스는 원본 값(`ModifiedDate`)을 기준으로 정렬되어 있으므로, 변환된 결과(`YEAR(ModifiedDate)`)를 직접 사용할 수 없음.
- 따라서 인덱스를 사용하지 못하고 테이블 스캔이 발생.

---

## 6. 정리
1. **인덱스의 정렬 상태**:
   - 인덱스는 항상 정렬된 상태를 유지하므로 테이블의 데이터 정렬 상태와 무관하게 빠른 검색이 가능.

2. **BETWEEN 조건의 효율성**:
   - 인덱스의 정렬 구조를 활용해 범위 검색에 유리.

3. **YEAR() 함수의 비효율성**:
   - 함수가 사용되면 인덱스를 사용할 수 없어 테이블 스캔이 발생.

